<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<!-- Material used from: HTML 4.01 specs: http://www.w3.org/TR/html401/ -->
<html>
<head>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>libc++ C++1Y Status</title>
  <link type="text/css" rel="stylesheet" href="menu.css">
  <link type="text/css" rel="stylesheet" href="content.css">
</head>

<body>
<div id="menu">
  <div>
    <a href="http://llvm.org/">LLVM Home</a>
  </div>

  <div class="submenu">
    <label>libc++ Info</label>
    <a href="/index.html">About</a>
  </div>

  <div class="submenu">
    <label>Quick Links</label>
    <a href="http://lists.cs.uiuc.edu/mailman/listinfo/cfe-dev">cfe-dev</a>
    <a href="http://lists.cs.uiuc.edu/mailman/listinfo/cfe-commits">cfe-commits</a>
    <a href="http://llvm.org/bugs/">Bug Reports</a>
    <a href="http://llvm.org/svn/llvm-project/libcxx/trunk/">Browse SVN</a>
    <a href="http://llvm.org/viewvc/llvm-project/libcxx/trunk/">Browse ViewVC</a>
  </div>
</div>

<div id="content">
  <!--*********************************************************************-->
  <h1>libc++ C++1Y Status</h1>
  <!--*********************************************************************-->

  <p>In April 2013, the C++ standard committee approved the draft for the next version of the C++ standard, known as "C++1Y" (probably to be C++14)</p>
  <p>The draft standard includes papers and issues that were voted on at the previous three meetings (Kona, Portland, and Bristol)</p>
  <p>This page shows the status of libc++; the status of clang's support of the language features is <a href="http://clang.llvm.org/cxx_status.html">here</a>.</p>

  <p>The groups that have contributed papers:
  <ul>
    <li>CWG - Core Language Working group</li>
    <li>LWG - Library working group</li>
    <li>SG1 - Study group #1 (Concurrency working group)</li>
  </ul>
  </p>
  
  <h3>Paper Status</h3>
  <table id="papers" border="1">
	<tr><th>Paper #</th><th>Group</th><th>Paper Name</th><th>Meeting</th><th>Status</th><th>First released version</th></tr>

	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3346.pdf">3346</a></td><td>LWG</td><td>Terminology for Container Element Requirements - Rev 1</td><td>Kona</td><td>Complete</td><td>3.4</td></tr>
	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>

<!-- 	<tr><td>3323</td><td>CWG</td><td>A Proposal to Tweak Certain C++ Contextual Conversions, v3</td><td>Portland</td><td></td><td></td></tr> -->
	
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">3421</a></td><td>LWG</td><td>Making Operator Functors greater&lt;&gt;</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3462.html">3462</a></td><td>LWG</td><td>std::result_of and SFINAE</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3469.html">3469</a></td><td>LWG</td><td>Constexpr Library Additions: chrono, v3</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3470.html">3470</a></td><td>LWG</td><td>Constexpr Library Additions: containers, v2</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">3471</a></td><td>LWG</td><td>Constexpr Library Additions: utilities, v3</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3302.html">3302</a></td><td>LWG</td><td>Constexpr Library Additions: complex, v2</td><td>Portland</td><td>Complete</td><td>3.4</td></tr>
	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>

<!-- 	<tr><td>3472</td><td>CWG</td><td>Binary Literals in the C++ Core Language</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3624</td><td>CWG</td><td>Core Issue 1512: Pointer comparison vs qualification conversions (revision 3)</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3639</td><td>CWG</td><td>Runtime-sized arrays with automatic storage duration (revision 5)</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3638</td><td>CWG</td><td>Return type deduction for normal functions</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3648</td><td>CWG</td><td>Wording Changes for Generalized Lambda-capture</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3653</td><td>CWG</td><td>Member initializers and aggregates</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3667</td><td>CWG</td><td>Drafting for Core 1402</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3652</td><td>CWG</td><td>Relaxing constraints on constexpr functions" and "constexpr member functions and implicit const</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3664</td><td>CWG</td><td>Clarifying Memory Allocation</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3651</td><td>CWG</td><td>Variable Templates (Revision 1)</td><td>Bristol</td><td></td><td></td></tr> -->
<!-- 	<tr><td>3649</td><td>CWG</td><td>Generic (Polymorphic) Lambda Expressions (Revision 3)</td><td>Bristol</td><td></td><td></td></tr> -->
	
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3545.pdf">3545</a></td><td>LWG</td><td>An Incremental Improvement to integral_constant</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf">3644</a></td><td>LWG</td><td>Null Forward Iterators</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3668.html">3668</a></td><td>LWG</td><td>std::exchange()</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html">3658</a></td><td>LWG</td><td>Compile-time integer sequences</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3670.html">3670</a></td><td>LWG</td><td>Addressing Tuples by Type</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3671.html">3671</a></td><td>LWG</td><td>Making non-modifying sequence operations more robust</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656.htm">3656</a></td><td>LWG</td><td>make_unique</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3654.html">3654</a></td><td>LWG</td><td>Quoted Strings</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3642.pdf">3642</a></td><td>LWG</td><td>User-defined Literals</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf">3655</a></td><td>LWG</td><td>TransformationTraits Redux (excluding part 4)</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm">3657</a></td><td>LWG</td><td>Adding heterogeneous comparison lookup to associative containers</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html">3672</a></td><td>LWG</td><td>A proposal to add a utility class to represent optional objects</td><td>Bristol</td><td><I>Removed from Draft Standard</I></td><td>n/a</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3669.pdf">3669</a></td><td>LWG</td><td>Fixing constexpr member functions without const</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3662.html">3662</a></td><td>LWG</td><td>C++ Dynamic Arrays (dynarray)</td><td>Bristol</td><td><I>Removed from Draft Standard</I></td><td>n/a</td></tr>
	
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3659.html">3659</a></td><td>SG1</td><td>Shared Locking in C++</td><td>Bristol</td><td>Complete</td><td>3.4</td></tr>

 	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://wiki.edg.com/twiki/pub/Wg21chicago2013/FormalMotions/N3779-complex_literals.pdf">3779</a></td><td>LWG</td><td>User-defined Literals for std::complex</td><td>Chicago</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://wiki.edg.com/twiki/pub/Wg21chicago2013/FormalMotions/N3789.txt">3789</a></td><td>LWG</td><td>Constexpr Library Additions: functional</td><td>Chicago</td><td>Complete</td><td>3.4</td></tr>
	<tr><td><a href="http://wiki.edg.com/twiki/pub/Wg21chicago2013/FormalMotions/n3778.html">3778</a></td><td>CWG</td><td>Sized deallocation</td><td>Chicago</td><td></td><td></td></tr>
<!--  	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr> -->
  </table>

  <h3>Library Working group Issues Status</h3>
<!--   <I>Note: "NAD" means that the issue was deemed "Not a defect"</I> -->
  <table id="issues" border="1">
	<tr><th>Issue #</th><th>Issue Name</th><th>Meeting</th><th>Status</th></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1214">1214</a></td><td>Insufficient/inconsistent key immutability requirements for associative containers</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2009">2009</a></td><td>Reporting out-of-bound values on numeric string conversions</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2010">2010</a></td><td>is_* traits for binding operations can't be meaningfully specialized</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2015">2015</a></td><td>Incorrect pre-conditions for some type traits</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2021">2021</a></td><td>Further incorrect usages of result_of</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028">2028</a></td><td>messages_base::catalog overspecified</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2033">2033</a></td><td>Preconditions of reserve, shrink_to_fit, and resize functions</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2039">2039</a></td><td>Issues with std::reverse and std::copy_if</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2044">2044</a></td><td>No definition of "Stable" for copy algorithms</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2045">2045</a></td><td>forward_list::merge and forward_list::splice_after with unequal allocators</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2047">2047</a></td><td>Incorrect "mixed" move-assignment semantics of unique_ptr</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2050">2050</a></td><td>Unordered associative containers do not use allocator_traits to define member types</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053">2053</a></td><td>Errors in regex bitmask types</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2061">2061</a></td><td>make_move_iterator and arrays</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2064">2064</a></td><td>More noexcept issues in basic_string</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2065">2065</a></td><td>Minimal allocator interface</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2067">2067</a></td><td>packaged_task should have deleted copy c'tor with const parameter</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2069">2069</a></td><td>Inconsistent exception spec for basic_string move constructor</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2096">2096</a></td><td>Incorrect constraints of future::get in regard to MoveAssignable</td><td>Kona</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2102">2102</a></td><td>Why is std::launch an implementation-defined type?</td><td>Kona</td><td>Complete</td></tr>
  <tr><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2071">2071</a></td><td>std::valarray move-assignment</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2074">2074</a></td><td>Off by one error in std::reverse_copy</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2081">2081</a></td><td>Allocator requirements should include CopyConstructible 2083 const-qualification on weak_ptr::owner_before</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2083">2083</a></td><td>const-qualification on weak_ptr::owner_before</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2086">2086</a></td><td>Overly generic type support for math functions</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2099">2099</a></td><td>Unnecessary constraints of va_start() usage</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2103">2103</a></td><td>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2105">2105</a></td><td>Inconsistent requirements on const_iterator's value_type</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2110">2110</a></td><td>remove can't swap but note says it might</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2123">2123</a></td><td>merge() allocator requirements for lists versus forward lists</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2005">2005</a></td><td>unordered_map::insert(T&&) protection should apply to map too</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2011">2011</a></td><td>Unexpected output required of strings</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2048">2048</a></td><td>Unnecessary mem_fn overloads</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2049">2049</a></td><td>is_destructible is underspecified</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2056">2056</a></td><td>future_errc enums start with value 0 (invalid value for broken_promise)</td><td>Portland</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2058">2058</a></td><td>valarray and begin/end</td><td>Portland</td><td>Complete</td></tr>
  <tr><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2091">2091</a></td><td>Misplaced effect in m.try_lock_for()</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2092">2092</a></td><td>Vague Wording for condition_variable_any</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2093">2093</a></td><td>Throws clause of condition_variable::wait with predicate</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2094">2094</a></td><td>duration conversion overflow shouldn't participate in overload resolution</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2122">2122</a></td><td>merge() stability for lists versus forward lists</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2128">2128</a></td><td>Absence of global functions cbegin/cend</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2145">2145</a></td><td>error_category default constructor</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2147">2147</a></td><td>Unclear hint type in Allocator's allocate function</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148">2148</a></td><td>Hashing enums should be supported directly by std::hash</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2149">2149</a></td><td>Concerns about 20.8/5</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2162">2162</a></td><td>allocator_traits::max_size missing noexcept</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2163">2163</a></td><td>nth_element requires inconsistent post-conditions</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2169">2169</a></td><td>Missing reset() requirements in unique_ptr specialization</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2172">2172</a></td><td>Does atomic_compare_exchange_* accept v == nullptr arguments?</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2080">2080</a></td><td>Specify when once_flag becomes invalid</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2098">2098</a></td><td>promise throws clauses</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2109">2109</a></td><td>Incorrect requirements for hash specializations</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2130">2130</a></td><td>missing ordering constraints for fences</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2138">2138</a></td><td>atomic_flag::clear ordering constraints</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2140">2140</a></td><td>notify_all_at_thread_exit synchronization</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2144">2144</a></td><td>Missing noexcept specification in type_index</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2174">2174</a></td><td>wstring_convert::converted() should be noexcept</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2175">2175</a></td><td>string_convert and wbuffer_convert validity</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2176">2176</a></td><td>Special members for wstring_convert and wbuffer_convert</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2177">2177</a></td><td>Requirements on Copy/MoveInsertable</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2185">2185</a></td><td>Missing throws clause for future/shared_future::wait_for/wait_until</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2187">2187</a></td><td>vector&lt;bool&gt; is missing emplace and emplace_back member functions</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2190">2190</a></td><td>ordering of condition variable operations, reflects Posix discussion</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2196">2196</a></td><td>Specification of is_*[copy/move]_[constructible/assignable] unclear for non-referencable types</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2197">2197</a></td><td>Specification of is_[un]signed unclear for non-arithmetic types</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2200">2200</a></td><td>Data race avoidance for all containers, not only for sequences</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2203">2203</a></td><td>scoped_allocator_adaptor uses wrong argument types for piecewise construction</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2207">2207</a></td><td>basic_string::at should not have a Requires clause</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2209">2209</a></td><td>assign() overspecified for sequence containers</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2210">2210</a></td><td>Missing allocator-extended constructor for allocator-aware containers</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2211">2211</a></td><td>Replace ambiguous use of "Allocator" in container requirements</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2222">2222</a></td><td>Inconsistency in description of forward_list::splice_after single-element overload</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2225">2225</a></td><td>Unrealistic header inclusion checks required</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2229">2229</a></td><td>Standard code conversion facets underspecified</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2231">2231</a></td><td>DR 704 removes complexity guarantee for clear()</td><td>Bristol</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2235">2235</a></td><td>Undefined behavior without proper requirements on basic_string constructors</td><td>Bristol</td><td>Complete</td></tr>
    <tr><td></td><td></td><td></td><td></td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2141">2141</a></td><td>common_type trait produces reference types</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2235">2235</a></td><td>Undefined behavior without proper requirements on basic_string constructors</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2246">2246</a></td><td>unique_ptr assignment effects w.r.t. deleter</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2247">2247</a></td><td>Type traits and std::nullptr_t</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2085">2085</a></td><td>Wrong description of effect 1 of basic_istream::ignore</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2087">2087</a></td><td>iostream_category() and noexcept</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2143">2143</a></td><td>ios_base::xalloc should be thread-safe</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2150">2150</a></td><td>Unclear specification of find_end</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2180">2180</a></td><td>Exceptions from std::seed_seq operations</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2194">2194</a></td><td>Impossible container requirements for adaptor types</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2013">2013</a></td><td>Do library implementers have the freedom to add constexpr?</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2018">2018</a></td><td>regex_traits::isctype Returns clause is wrong</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2078">2078</a></td><td>Throw specification of async() incomplete</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2097">2097</a></td><td>packaged_task constructors should be constrained</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2100">2100</a></td><td>Timed waiting functions cannot timeout if launch::async policy used</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2120">2120</a></td><td>What should async do if neither 'async' nor 'deferred' is set in policy?</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2159">2159</a></td><td>atomic_flag initialization</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2275">2275</a></td><td>Why is forward_as_tuple not constexpr?</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2284">2284</a></td><td>Inconsistency in allocator_traits::max_size</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2298">2298</a></td><td>is_nothrow_constructible is always false because of create&lt;&gt;</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2300">2300</a></td><td>Redundant sections for map and multimap members should be removed</td><td>Chicago</td><td>Complete</td></tr>
	<tr><td>National Body comment 'GB 9'</td>                                                        <td>Remove gets from C++14</td><td>Chicago</td><td>Complete</td></tr>
<!--  	<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr> -->
  </table>

  <p>Last Updated: 22-Oct-2013</p>
</div>
</body>
</html>
